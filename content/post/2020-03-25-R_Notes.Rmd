---
title: "R Notes March 25, 2020"
author: "Elisha Cohen"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Matrices in R!

We can start by creating a 3X3 matrix and filling it with the numbers 1 to 9:

```{r c1}
A <- matrix(1:9, nrow = 3, ncol = 3, byrow = TRUE)
A
```

If we use the `class()` function to check the class it should be of the matrix class:

```{r c2}
class(A)
```
This can be important because if matrix operations aren't working it may be that our object is a data.frame or tibble.

Many of the commands we are used to using on other objects continue to work with matrices. We can add a row or add a column:

```{r c3}
## add a row
A <- rbind(A,c(10,11,12))
A
## add a column
A <- cbind(A,c(10,20,30,40))
A
```

To access specific elements, rows or columns we use square brackets always specifying row first then column. Currently our `A` matrix has 4 rows and 4 columns.
```{r c4}
# element in the 2nd row, 3rd column
A[2,3]
```
To return the $m^{th}$ row:
```{r}
# return the entire 3rd row
A[3,]
```
To return the $n^{th}$ column:
```{r}
# return the entire 4th column
A[,4]
```
If we want to multiply the matrix by a scaler:
```{r}
A*2
```
Let's make a 2nd matrix, this time a 4X4 identity matrix:
```{r}
B <- diag(c(1,1,1,1))
B
```
To multiply matrices use `%*%`
```{r}
A%*%B
```
Note, that the dimensions must match just like with normal matrix operations. So if we have a matrix that is only 3X3 we will get an error that the arguments are non-comformable.
```{r}
C <- matrix(rep(1,8), nrow = 2, ncol = 4)
```
```{r,eval=FALSE}
A%*%C
```
We can transpose a matrix
```{r}
C <- t(C)
```
Now because we have a matrix that is 4X4 and a matrix that is 4X2 our matrix multiplication will work
```{r}
A%*%C
```
To return the inverse of a matrix use solve
```{r}
A <- matrix(1:4,nrow=2,ncol=2)
A
solve(A)
```
You can convert a data.frame to a matrix in order to use matrix operations
```{r}
mtcars_matrix <- matrix(mtcars)
class(mtcars_matrix)
```

## Gapminder
Let's switch gears and look at the gapminder data.
```{r}
library(gapminder)
```

We will look at the relationship between life expectancy and year controlling for population, and GDP per capita. We expect that life expectancy has increased as time has passed. First, will start with a scatter plot to descriptively look at the relationship. This plots the life expectance of all countries over time.

```{r}
library(ggplot2)
library(dplyr)
ggplot(data = gapminder, aes(x = year, y = lifeExp)) +
  geom_point() +
  ylab('Life Expectancy') +
  xlab('Year') +
  theme_bw()
```
We can add a fitted line
```{r,message=FALSE}
ggplot(data = gapminder, aes(x = year, y = lifeExp)) +
  geom_point() +
  geom_smooth(method='loess', color = 'blue', se=FALSE) +
  ylab('Life Expectancy') +
  xlab('Year') +
  theme_bw()
```
It looks like there is a positive relationship between year and life expectancy. 

We can also fit a regression line using `ggplot2`
```{r,message=FALSE}
ggplot(data = gapminder, aes(x = year, y = lifeExp)) +
  geom_point() +
  geom_smooth(method='lm', color = 'blue', se=FALSE) +
  ylab('Life Expectancy') +
  xlab('Year') +
  theme_bw()
```

Now we will fit a linear model of the form:
$$y = \beta_0 + X \beta + \epsilon$$
where $X$ is a 1706 X 4 matrix because there are 1706 observations (rows) and 4 variables. We can use the built in function `lm()` to run a linear model with life expectancy as our dependent variable. First, convert the population variable into a logged value.
```{r}
gapminder$pop_log <- log(gapminder$pop) # make a logged population variable
```
Then estimate the linear model
$$\hat{y} = \hat{\beta}_0 + X\hat{\beta}$$
```{r}
fit <- lm(lifeExp ~ year + country + pop_log + gdpPercap, data = gapminder)
```
There are two functions we can use to get the fitted values
```{r}
gapminder$yhat <- fit$fitted.values
gapminder$yhat <- fitted.values(fit)
```
We can check that the difference between our observed $y$ and our $\hat{y}$ is equal to our residuals.
```{r}
r <- gapminder$lifeExp - gapminder$yhat
resid <- as.numeric(fit$residuals)
all.equal(r, resid)
```

What is the predicted life expectancy for the United States in 1952 and in 2007?
```{r}
US1952 <- gapminder %>% filter(country=='United States' & year==1952)
predict_US1952 <- predict(fit, newdata = US1952)

US2007 <- gapminder %>% filter(country=='United States' & year==2007)
predict_US2007 <- predict(fit, newdata = US2007)
predict_US1952;predict_US2007
```
We can also extract the variance-covariance matrix from our regression results
```{r}
fit_vcov <- vcov(fit)
fit_vcov[1:3,1:3]
#extract standard errors
se <- summary(fit)$coefficients[,2] # we want 2nd column
head(se^2,3)
```
The variance-covariance matrix has the variance along the diagonal and we can see that it matches the variance.